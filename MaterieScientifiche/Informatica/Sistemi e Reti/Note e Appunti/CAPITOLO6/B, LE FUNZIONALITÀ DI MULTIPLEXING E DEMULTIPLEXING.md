La creazione delle Socket permette di realizzare le funzionalità di multiplexing e demultiplexing:

- **multiplexing**: ==**in trasmissione** il livello Transport **riceve i dati dalle Socket e aggiunge le proprie informazioni di controllo** (header)==; 
- **demultiplexing**: ==in ricezione il livello Transport **legge l’header e determina a quale Socket consegnare i dati**==.

**Per aver un’idea più chiara** di questa funzionalità, che è particolarmente critica, si può far **riferimento al servizio postale tradizionale** che **recapita più lettere nella cassetta della posta di una famiglia** (*il cui indirizzo di abitazione equivale all’indirizzo IP dell’host*). **L’attività di demultiplexing consiste nel prendere le lettere dalla cassetta e consegnarle ai vari membri della famiglia destinatari di ciascuna di esse**. Al contrario, **l’attività di multiplexing consiste nel ricevere varie lettere dai diversi membri della famiglia e inserirle in un’unica cassetta di spedizione**. La seguente [[Sistemi e reti(Internetworking).pdf#page=282&selection=41,0,43,0&color=yellow|FIGURA 7]] mostra l’operazione di demultiplexing effettuata dal livello Transport dell’host X, che riceve i dati dal processo P3, residente sull’host A, per il processo P1 e dal processo P4, residente sull’host B, per il processo P2 .I dati ricevuti vengono inviati ai processi destinatari tramite 1 interfaccia socket (ossia la destination port) specificata nel messaggio ricevuto.

==Le operazioni di multiplexing/demultiplexing possono avvenire sia in presenza, che in assenza, di una connessione==: 
- ==multiplexing/demultiplexing connectionless==: è il caso del ==protocollo UDP== (descritto nella Lezione 3) in cui ==è previsto che più client accedano allo stesso servizio sullo stesso server==. **La socket è individuata in questo caso solo dalla coppia**:
	Server IP address | Server Port number
	di 32 e 16 bit, rispettivamente;

- ==multiplexing/demultiplexing connection-oriented==: è il caso del protocollo ==TCP== (descritto nella Lezione 4) in cui ==è previsto che più client accedano allo stesso servizio sullo stesso server e che uno stesso client possa attivare più sessioni dello stesso servizio==. **Le connessioni che vengono stabilite sono identificate dalla socket completa** cioè dalla quadrupla:
	- Client IP address | Server IP address | Client Port number | Server Port number
	di 32, 32, 16 e 16 bit rispettivamente.

> [!PDF|yellow] [[Sistemi e reti(Internetworking).pdf#page=283&selection=36,0,44,22&color=yellow|Si noti che, nei due punti sopra elencati, si è fatto uso della terminologia client-server al posto di host mittente (source) e host ricevente (destination), in quanto è proprio a livello Transport che si inizia a individuare come la comunicazione in Internet avvenga tipicamente tra un’applicazione client e un’applicazione server, presente su un computer remoto.]]
> > Si noti che, nei due punti sopra elencati, si è fatto uso della terminologia client-server al posto di host mittente (source) e host ricevente (destination), in quanto è proprio ==a livello Transport== che si inizia a individuare come ==la comunicazione in Internet avvenga tipicamente tra un’applicazione client e un’applicazione server, presente su un computer remoto==.

Questo concetto è esemplificato nella [[Sistemi e reti(Internetworking).pdf#page=283&selection=87,0,88,1&color=yellow|FIGURA 8]], dove si fa riferimento al servizio World Wide Web presente sul computer B, al quale si connettono le applicazioni client presenti sui computer A e C. In questo esempio è necessario usare il multiplexing/demultiplexing connection-oriented. Nell’esempio raffigurato, il PC www client, host A, invia al www server, host B, un segmento con **destination port number** 80 (il numero di porta assegnato da IANA alle applicazioni che usano il protocollo HTTP), mentre come **source port number** specifica un numero (x in Figura 8) che non è usato da nessun altro processo su quel computer. Ogni segmento che l’host A invierà all’host B avrà source port = x e destination port = 80.
Quando il segmento arriva al server B, questi potrà consegnarlo al processo applicativo corretto, associato alla destination port 80 (porta standard del processo HTTP sul server B) e potrà rispondere con un messaggio indirizzato alla source port x (porta specifica del processo HTTP che gestisce la richiesta sul client A). Quindi, simmetricamente, i segmenti che il server B invia al client A avranno source port = 80 e destination port = x; tale coppia permetterà ad A di iden tificare il processo applicativo corretto a cui consegnare il segmento ricevuto. Il livello Transport trova automaticamente un numero di porta libero da usa re come source port x, in modo trasparente all’applicazione. Su alcuni sistemi esiste comunque la possibilità che l’applicazione richieda in modo esplicito di usare un determinato numero di porta (per esempio nei sistemi Unix-like si usa a questo scopo la System cali bind() descritta nella Tabella 1 della Lezione 1). Dal momento che la scelta del source port number è fatta a livello del singolo client, può capitare che due client utilizzino lo stesso numero (Figura 8, dove sia A che C hanno scelto il numero x), questo però non causa conflitti in quan to il server usa anche l’indirizzo IP (e i due host, A e C, hanno un indirizzo IP distinto).

--- 
[[C, UN PROTOCOLLO DI TRASPORTO CONNECTIONLESS (UDP)]]
